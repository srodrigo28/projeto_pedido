create table loja_perfil (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  nome text null,
  email text null,
  foto_perfil text null,
  sexo text null,
  pais text null,
  estado text null,
  
  user_id uuid null,
  empresa_id bigint null,
  constraint loja_perfil_pkey primary key (id),
  constraint loja_perfil_user_id_fkey foreign KEY (user_id) references auth.users (id) on update CASCADE on delete CASCADE
) TABLESPACE pg_default;

create table loja_empresa (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  nome text null,
  logo text null,
  
  perfil_id bigint null,
  constraint loja_empresa_pkey primary key (id),
  constraint loja_empresa_perfil_id_fkey foreign KEY (perfil_id) references loja_perfil (id) on update CASCADE on delete CASCADE
) TABLESPACE pg_default;

create table loja_produto (
  id bigint primary key generated always as identity,
  created_at timestamp with time zone not null default now(),
  nome text not null,
  preco numeric(10, 2) not null
  foto_produto text not null,
);

create table loja_pedido (
  id bigint primary key generated always as identity,
  created_at timestamp with time zone not null default now(),
  total numeric(10, 2) not null default 0
);

create table loja_pedido_item (
  id bigint primary key generated always as identity,
  created_at timestamp with time zone not null default now(),
  pedido_id bigint references pedido (id) on delete cascade,
  produto_id bigint references produto (id) on delete cascade,
  
  quantidade integer not null,
  preco_unitario numeric(10, 2) not null,
  total_item numeric(10, 2) not null
);

/*
Objetivo: representar os itens dentro de um pedido.

üí° Campos:
    id: chave prim√°ria.
    pedido_id: chave estrangeira ‚Üí indica a qual pedido o item pertence.
    produto_id: chave estrangeira ‚Üí qual produto foi comprado.
    quantidade: n√∫mero de unidades.
    preco_unitario: pre√ßo do produto no momento da venda (importante, 
    porque pode ser diferente do pre√ßo atual em produto).
    total_item: valor total do item (quantidade √ó preco_unitario).
üí° Boas pr√°ticas aplicadas:
    Guardar o preco_unitario evita inconsist√™ncia caso o pre√ßo do produto mude depois.
    O total_item tamb√©m √© armazenado para agilizar c√°lculos (embora pudesse ser calculado "on the fly").
*/
create
or replace function update_pedido_total () returns trigger as $$
BEGIN
    UPDATE loja_pedido
    SET total = (SELECT COALESCE(SUM(total_item), 0) FROM pedido_item WHERE pedido_id = NEW.pedido_id)
    WHERE id = NEW.pedido_id;
    RETURN NEW;
END;
$$ language plpgsql;

    /*
      üí° Objetivo: manter o campo pedido.total sempre atualizado automaticamente.
          Sempre que um item √© inserido ou atualizado em pedido_item, o trigger dispara e:
          Soma todos os total_item daquele pedido.
          Atualiza o valor de pedido.total.

      üí° Observa√ß√µes:
          Isso elimina risco de inconsist√™ncia entre o que est√° em pedido e os itens.
          Por√©m, ainda n√£o cobre o caso de DELETE em pedido_item. Se um item for removido, 
          o total n√£o ser√° atualizado. Nesse caso, seria bom incluir tamb√©m AFTER DELETE.
    */
create trigger update_pedido_total_trigger
after insert
or
update on loja_pedido_item for each row
execute function update_pedido_total ();

/**    
    üìå An√°lise geral
    
    ‚úÖ Pontos fortes:
        Estrutura clara e simples, com separa√ß√£o entre entidades (produto, pedido, pedido_item).
        Boa pr√°tica em salvar preco_unitario e total_item no momento da venda.
        Trigger garante que o pedido.total esteja sempre atualizado.
        Uso de on delete cascade ‚Üí remove automaticamente os itens de um pedido apagado (evita lixo no banco).
    
    ‚ö†Ô∏è Poss√≠veis pontos de melhoria:
        Trigger incompleto: n√£o cobre DELETE em pedido_item.
        Solu√ß√£o: adicionar AFTER DELETE no mesmo trigger.
        Duplica√ß√£o de dados (total_item): j√° que √© quantidade * preco_unitario, pode ser calculado em runtime. Mas manter facilita consultas e 
        relat√≥rios ‚Üí trade-off entre espa√ßo e performance.
        Campo total em pedido: tamb√©m √© redundante (pois pode ser calculado via SUM(total_item)), mas est√° ok porque melhora desempenho e 
        simplifica consultas.
        Faltam atributos em pedido: normalmente ter√≠amos cliente, data do pedido, status (em aberto, pago, cancelado etc.).
*/